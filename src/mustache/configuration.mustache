{{! Copyright(c) 1995 - 2018 T-Systems Multimedia Solutions GmbH }}
{{! Riesaer Str. 5, 01129 Dresden }}
{{! All rights reserved. }}
import { HttpHeaders, HttpParams } from '@angular/common/http';
import { Observable } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { CustomHttpUrlEncodingCodec } from './encoder';

export interface ConfigurationParameters {
    apiKeys?: {[ key: string ]: string};
    username?: string;
    password?: string;
    accessToken?: string | (() => string);
    errorHandler?: (err: any, operationName: string) => Observable<never>;
    basePath?: string;
    withCredentials?: boolean;
}

export class Configuration {
    apiKeys?: {[ key: string ]: string};
    username?: string;
    password?: string;
    accessToken?: string | (() => string);
    errorHandler?: (err: any, operationName: string) => Observable<never>;
    basePath?: string;
    withCredentials?: boolean;

    constructor(configurationParameters: ConfigurationParameters = {}) {
        this.apiKeys = configurationParameters.apiKeys;
        this.username = configurationParameters.username;
        this.password = configurationParameters.password;
        this.accessToken = configurationParameters.accessToken;
        this.errorHandler = configurationParameters.errorHandler;
        this.basePath = configurationParameters.basePath;
        this.withCredentials = configurationParameters.withCredentials;
    }

    /**
     * Select the correct content-type to use for a request.
     * Uses {@link Configuration#isJsonMime} to determine the correct content-type.
     * If no content type is found return the first found type if the contentTypes is not empty
     * @param contentTypes - the array of content types that are available for selection
     * @returns the selected content-type or <code>undefined</code> if no selection could be made.
     */
    private selectHeaderContentType (contentTypes: string[]): string | undefined {
        if (contentTypes.length === 0) {
            return undefined;
        }

        let type = contentTypes.find(x => this.isJsonMime(x));
        if (type === undefined) {
            return contentTypes[0];
        }
        return type;
    }

    /**
     * Select the correct accept content-type to use for a request.
     * Uses {@link Configuration#isJsonMime} to determine the correct accept content-type.
     * If no content type is found return the first found type if the contentTypes is not empty
     * @param accepts - the array of content types that are available for selection.
     * @returns the selected content-type or <code>undefined</code> if no selection could be made.
     */
    private selectHeaderAccept(accepts: string[]): string | undefined {
        if (accepts.length === 0) {
            return undefined;
        }

        let type = accepts.find(x => this.isJsonMime(x));
        if (type === undefined) {
            return accepts[0];
        }
        return type;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    public canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }

    /**
     * Check all required parameters that they are non-null and non-undefined.
     */
    public checkRequired(nickname: string, parameters: { [key: string]: any }) {
        for (const key of Object.keys(parameters)) {
            if (parameters[key] == null) {
                throw new Error(`Required parameter ${key} was null or undefined when calling ${nickname}.`);
            }
        }
    }

    /**
     * Add standard Content-Type and Accept headers and optionally merge additional headers.
     */
    public mergeHeaders(headers: HttpHeaders, contentTypes: string[], accepts: string[], additionalHeaders: string[][]) {
        // set Content-Type header
        const httpContentTypeSelected: string | undefined = this.selectHeaderContentType(contentTypes);
        if (httpContentTypeSelected !== undefined && httpContentTypeSelected.length > 0) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        // set Accept header
        const httpHeaderAcceptSelected: string | undefined = this.selectHeaderAccept(accepts);
        if (httpHeaderAcceptSelected !== undefined && httpHeaderAcceptSelected.length > 0) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // set additional headers
        if (additionalHeaders) {
            for (let pair of additionalHeaders) {
                headers = headers.set(pair[0], pair[1]);
            }
        }
    }

    /**
     * If errorHandler is non-null, pipe result error through error handler.
     */
    public handleErrors<T>(nickname: string): (o: Observable<T>) => Observable<T> {
        return (observable: Observable<T>) => {
            if (typeof this.errorHandler === 'function') {
                return observable.pipe(catchError(err => this.errorHandler(err, nickname)));
            } else {
                return observable;
            }
        }
    }

    /**
     * Build HttpParams structure for query parameters.
     */
    public buildQueryParams(parameters: Array<[string, any, ('multi' | 'collection')?, string?]>): HttpParams {
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        for (const [name, value, type, collectionFormat] of parameters) {
            if (value == null) continue;
            if (type === 'multi') {
                for (const element of value) {
                    queryParameters = queryParameters.append(name, element);
                }
            } else if (type === 'collection') {
                queryParameters = queryParameters.set(name, value.join(collectionFormat));
            } else {
                let valueFmt = value;
                if (value instanceof Date) valueFmt = value.toISOString();
                queryParameters = queryParameters.set(name, valueFmt);
            }
        }
        return queryParameters;
    }

    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    private isJsonMime(mime: string): boolean {
        const jsonMime: RegExp = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
}
